Make "How to Learn" posts on Developer Forge


Data Structures, Algorithms and System Design Handbook
		Memorisation is not good: https://en.wikipedia.org/wiki/List_of_algorithms
		There's too many algorithms
		If you just memorise Leetcode solutions, don't worry there's only 2093- https://leetcode.com/problemset/all/?page=42





Progress is not always linear
I've written before about how to improveAnd how to not give upProgress isn't linearProfress is broken down into discrete stepsYou either know JavaScript or don't know JavaScriptThen front lever example
Step 1
Tuck lever
Step 2
Frog progression
Step 3
Straddle
Step 4
Full front lever
Each new step is success and you're one step closer to the final stepBut it's not like that Friend who couldnt lift more, but could slowly lower moreThen Dislocated bicep
Draw diagram on tablet about wavey graph by hand about how progress looks

Capture.JPG









Salary negociations
https://youexec.com/book-summaries/bargaining-for-advantage
https://www.goodreads.com/book/show/26156469-never-split-the-difference
https://fourminutebooks.com/getting-to-yes-summary/
https://blog.pragmaticengineer.com/software-engineering-salaries-in-the-netherlands-and-europe/
https://www.levels.fyi/Salaries/Software-Engineer/United-Kingdom/https://www.kalzumeus.com/2012/01/23/salary-negotiation/
https://fearlesssalarynegotiation.com/book/
https://fearlesssalarynegotiation.com/salary-negotiation-email-sample/#ask-for-time-template - Salary negotiation email samples and a counter offer letter template
https://fearlesssalarynegotiation.com/salary-negotiation-script/ - How to counter a job offer - Salary negotiation script & calculator
https://haseebq.com/farewell-app-academy-hello-airbnb-part-i/https://www.freecodecamp.org/news/ten-rules-for-negotiating-a-job-offer-ee17cccbdab6/
https://www.freecodecamp.org/news/how-not-to-bomb-your-offer-negotiation-c46bb9bc7dea/#.w30tfvb9r
https://www.levels.fyi/








What Employers Value
one last look thru eliwih for what could be relevant to the matrices
some useful stuff on Junior to senior right ? All these ones: https://github.com/kealanparr/Every-link-I-wish-I-had-as-a-beginner#Junior-to-regular-developer
Create github repo of all the matrices to share in the article for people to look at
Google the big 5 companies for their compotency matrix
google
fb
microsoft
amazon
apple
netlfix
air b n b
If you cant find they dont have- just move on, dont look at every single companies matrix, already got about 30
Run thru all bookmarks on folder "matrix"








Make it work, make it right, make it fast








How to scale yourself as a developer
Profesional development:Im not a great programmer, im just a good programmer with great habbitskent beck
make decision with systems
- like always taking the stairs not the elevator
The system then forges a path, with side effects of improving cardio health

the way you imrpove is deliberate practice
-doing things that challenge you to the point you almost cant do them
working each day is not 8hrs of imrpvoement
it is likely maybe 6hrs of doing the same crud apps with different business problems

multithread your life
- turn your 50min commute (avg) which works out to 5.5 weeks @ 40hrs yearly
then do things to progress you
like listen to podcasts or pluralsight
or listen to audiobooks

this will give you freedom and impact
money follows this
freedom to move jobs
freedom to increase charges

you can only sell an hour of your life once
- scale yourself
- then build yourself to scale other things
One way of scaling is being promoted and now dealing with telling other people what to do

increase your luck surface area

work out a way you can speak at conferences



















Newbies - embrace abstractions

Learn as you need to learn it
Newbies want to understand the very lowest lowest level
Not useful- you need to rely on abstractions to get started


People chase down to the very basest abstractions
Developers often use abstractions in code to simplify a system.
Abstractions are a way of hiding complicated code inside something, and they normally provide an easy interface to use it.
So for example, let's say we have some complex code that ends up doing lots of very specific math. We can wrap all that logic up in a function and provide a really easy interface where you just pass in your number and the function will do the work.
We are essentially not forcing the person who uses our code to worry about the implementation details. They can just call the function and they'll get their answer back â€“ they don't have to worry about what the function is doing "under the hood".
That's the strength of abstracting details away in your code.
You can abstract things away in a multitude of data structures or code architecture. And you can abstract implementation details inside a prototype, class, function or more.If you had to understand every single line of code in a big codebase (let's say a 2 million line codebase) you'd never be able to start coding.
You can create a reusable, simple to understand, and easily changeable codebase by abstracting away certain details into the correct modules/separating out your code.
How code abstraction works
An example of abstracting away logic would be: imagine if you were creating a machine to make coffee for your users. There could be two approaches:
How to Create it With Abstraction
Have a button with the title "Make coffee"
How to Create it Without Abstraction
Have a button with the title "Boil the water"
Have a button with the title "Add the cold water to the kettle"
Have a button with the title "Add 1 spoon of ground coffee to a clean cup"
Have a button with the title "Clean any dirty cups"
And all the other buttons
Can you see how when we use abstraction we don't expect the user to know how the machine makes coffee? But in the machine without abstraction, the user has to know in which order to press each button which forces the user to understand how the coffee is made.
There's one definition we need to cover before we can move on and understand the concept I introduced at the beginning (always shim your abstractions), and that's shimming.




























Open Source What You Know
Luck surface area
Open source what you know
Build a second brain
Swyx
https://blog.codinghorror.com/when-in-doubt-make-it-public/














